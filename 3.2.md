#### CHECK

The CHECK constraint verifies that the values being added to a column meet specific requirements defined by the user. This uses a Boolean expression to evaluate whether the value is valid when inserted into or updated into the column. 

If the CHECK returns valid, the database will insert or update those values in the column.

If the CHECK is not valid, the database will reject the changes and raise an error.

This constraint is usually set up when the table is created. 

Here is an example of the table being created that would also implement CHECK:

>CREATE TABLE member (
>	member_id SERIAL PRIMARY KEY,
>	first_name VARCHAR(50),
>	last_name VARCHAR(50),
>	birth_date DATE CHECK (birth_date > '1900-01-01'),
>	joined_date DATE CHECK (joined_date > birth_date),
>	opt_in CHAR(1) CHECK (opt_in IN ('Y', 'N')),
>	membership_fee numeric CHECK(membership_fee > 0)
>);

The above table has four CHECK constraints associated with their related data type.
- The first one checks that the birth date occurs after the year 1900.
- The second checks to make sure the join date occurs after the birth date.
- The third is based on the opt_in column and is a single character allowing for only Y or N.
- The last check verifies that the membership_fee is greater than zero.

In PostgreSQL the constraint names are automatically generated using the table name, column name, and type of constraint used separated by underscores.

If you want to add a CHECK constraint to a table that already exists, you will need to use an ALTER TABLE statement along with a ADD CONSTRAINT clause. This would look similar to the statement shown below:

>ALTER TABLE member
>ADD CONSTRAINT birth_date_check
>CHECK (birth_date > '1900-01-01);

#### UNIQUE

The UNIQUE constraint is applied to ensure that no duplicate value exists in any existing records. If there is a duplicate, it will be rejected and an error message will be displayed.

#### ALTER TABLE

While it is ideal to add all constraints and rules to a table when it is created, there will be times where they must be added retroactively. In these cases, the ALTER TABLE statement will allow us to add constraints like UNIQUE.

The syntax for adding a UNIQUE constraint to an existing table is shown below:

>ALTER TABLE \<tablename> ADD CONSTRAINT \<constraintname> UNIQUE(\<column>);

The ADD CONSTRAINT clause indicates that you want to add a constraint and the UNIQUE function will specify which columns to make unique.

The ALTER TABLE statement will not run if the existing data in the table violates the constraint you want to implement. 

Try using the following statement within your sample database:

>ALTER TABLE customer ADD CONSTRAINT email_unique UNIQUE(email);

This should run successfully. To test this, display a list of all customer IDs and related emails:

>SELECT customer_ID, email
>FROM customer;

This should reveal 59 results.

In the following example we will set the customer with customer_id 1 to have the same email as customer_id 3:

>UPDATE customer
>SET email = '\ftremblay@gmail.com'
>WHERE customer_id = 1;

#### Adding Columns

While changing columns is uncommon and not ideal, sometimes the nature of the organization will require that this happens.

When we are experiencing difficulties in adding a column, it is likely due to a constraint acting in a prohibitive way. This is common when trying to add a NOT NULL column to a table with existing data. Doing this will render all existing records invalid because they don't have any data they can pull for the column.

To work around this, you will need to create a column with the NULL property and later enter filler data before setting the entire column to NOT NULL.

ALTER TABLE has three modifiers: ADD, MODIFY, and DROP.

The syntax for adding a column is as follows:

>ALTER TABLE \<tablename>
>ADD \<columnname>\<datatype>;

This is similar to the CREATE TABLE command.

Consider creating the following table:

>CREATE TABLE contact(contact_id SERIAL PRIMARY KEY);

We would then alter this new table to add the username field as seen below:

>ALTER TABLE contact
>ADD username VARCHAR(50);

Or we could add multiple columns with the following statement:

>ALTER TABLE contact
>ADD password VARCHAR(50),
>ADD email VARCHAR(50);

The DROP modifier allows us to remove a column from the table. In some DBMS, you will not be able to remove a column unless the column is NULL. This is to prevent the deletion of important data that other tables may be using. It is vital to backup your database before ever committing to a modification using the DROP modifier.

To remove a column, see the statement below:

>ALTER TABLE \<tablename>
>DROP \<columnname>;

This can be used to perform multiple drops at once, as shown below:

>ALTER TABLE contact
>DROP password,
>DROP email;

#### Changing Data Type

In the case of PostgreSQL, when we change the data type, it will convert all existing values to the new data type. This is known as Casting. If casting the data type into a new format fails, this will cause errors to occur.

Casting is when the data type for all entries is changed when the column's data type is changed.

Note that all data types cannot be changed. It is impossible to change the VARCHAR type to INT. It also matters whether you are using BIG INT or TINY INT. You can go from big to tiny, but you cannot go from tiny to big.

The syntax for changing data type is shown below:

>ALTER TABLE \<tablename>
>ALTER COLUMN \<columnname>
>TYPE \<newdatatype>;

Let's create a new table and then modify it using these techniques:

>CREATE TABLE contact(
>	contact_id int PRIMARY KEY,
>	username VARCHAR(50),
>	password VARCHAR(50),
>	opt_in int
>);

Now we will add sample data to the table:

>INSERT INTO contact VALUES(1, 'bob798', 'mypass1', 1);
>INSERT INTO contact VALUES(2, 'jen798', 'mypass2', 1);
>INSERT INTO contact VALUES(3, 'ran798', 'mypass3', 1);

#### Modifying Column Size

Column size might change because you need to accommodate larger entries or you overestimated the size of the entries to be made in the column. While decreasing column width is allowed, you should ensure that it will not result in loss of data before committing to this action.

The syntax for chaning column size is shown below:

>ALTER TABLE \<tablename>
>ALTER COLUMN \<columnname>
>TYPE \<newdatatype>

Consider the following table creation:

>CREATE TABLE registration(
>	registration_id  int PRIMARY KEY,
>	first_name VARCHAR(10),
>	last_name VARCHAR(10),
>	email VARCHAR(30),
>	fee NUMERIC(4,2)
>);

Now try to add the following data:


>INSERT INTO registration VALUES (1,'Michelle','Pippen','mpippen@a.com',9.99);
IINSERT INTO registration VALUES (2, 'Santana','Smith','smith@b.com',9.99);

This should display the two relevant rows.

Here is an example where we made changes to more than one column at a time:

>ALTER TABLE registration
>ALTER COLUMN first_name
>TYPE VARCHAR(50),
>ALTER COLUMN email
>TYPE VARCHAR(100);

This will limit our 'fee' field to only four digits, two decimal places. We can further modify this with the following statement:

>ALTER TABLE registration
>ALTER COLUMN fee
>TYPE numeric(6,2);

#### DROP TABLE

BE AWARE THAT A DROPPED TABLE IS INSTANTANEOUSLY GONE FOR GOOD. IT WILL ALSO DROP ALL INDEXES, CONSTRAINTS, SYNONYMS, TRIGGERS, AND PRIVILEGES ASSOCIATED WITH IT.

When you remove a table you will also need to remove all associated views, dashboards, and programs others have mad that rely on the table that was dropped.

A drop table statement is shown below:

>DROP TABLE \<tablename>;

This is an easy statement to write but can get more complicated when other tables are relationally involved with the one you are dropping.

When the relationship between tables involved foreign keys, you can only drop the table if it is the 'many' table in a one-to-many relationship. If you try to drop the table on the 'one' end of the relationship you will get an error.

To drop a table with these types of relationships, you must first find the constraints and remove them. This may be the foreign key relating the tables. Once you have identified and removed the constraints, you can work out the order for removing the tables.

----------
### IMPORTANT COMMAND FOR FINDING THE FOREIGN KEYS 

You can accomplish this by running the following command:

>SELECT conrelid::regclass AS table_name,
>	conname AS foreign_key,
>	pg_get_constraintdef(oid)
>FROM pg_constraint
>WHERE contype = 'f'
>AND connamespace = 'public'::regnamespace
>ORDER BY conrelid::regclass:text, contype DESC;

DIRECTLY FROM SOPHIA

```
SELECT conrelid::regclass AS table_name,
   conname AS foreign_key,
   pg_get_constraintdef(oid)
FROM pg_constraint
WHERE contype = 'f'
AND connamespace = 'public'::regnamespace
ORDER BY conrelid::regclass::text, contype DESC;
```

SAVE THIS COMMAND as it is important as a generic way of listing out all foreign keys in the database for every table.

#### CASCADE

The DROP TABLE statement has a CASCADE option that will drop the table and any constraints that link to the table.

An example is:

>DROP TABLE customer CASCADE;

This will drop the table and remove the foreign key constraint on the invoice table for customer_id.

#### IF EXISTS

The DROP TABLE statement also has an IF EXISTS option that will allow you to run a drop table command without returning an error.

If we ran the following statement and got an error:

>DROP TABLE cutsomer

Then we could run the following command to prevent the error from being returned:

>DROP TABLE IF EXISTS cutsomer;

### Aggregate Functions

An Aggregate is the combination of individual items or objects into a single set that are treated as a single unit.

In many cases databases work better when using data sets instead of individual records. Many solutions can be found when you aggregate data into a single unit.

Most databases share a common set of commands for data aggregation, although some special features are available for certain DBMS.

Functions that operate on multiple records to answer questions within queries are known as aggregate functions. They often provide information based on calculations they perform

Here is a list of common aggregate functions:

- AVG - calculates averages for non-null values.

>SELECT AVG(total)
>FROM invoice;

- COUNT - returns the number of rows as a result set.

>SELECT COUNT(customer_id)
>FROM customer
>WHERE country = 'USA';

- MAX - returns the largest of the non-null values.

>SELECT MAX(total)
>FROM invoice
>WHERE invoice_date between 'x' and 'y';

- MIN - returns the smallest of the non-null values.

>SELECT MIN(total)
>FROM invoice
>WHERE invoice_date < 'x';

- SUM - returns the sum of all the non-null values.

>SELECT SUM(quantity)
>FROM invoice_line;

- STDDEV - finds the standard deviation of all non-null values in a table.

>SELECT 
>ROUND(STDDEV(duration_minutes), 2) AS standard_deviation
>FROM netflix_titles;

- VARIANCE - finds the variance of all non-null values within a table.

>SELECT 
>ROUND(SQRT(VARIANCE(duration_minutes)), 2) AS stddev_using_variance
>FROM netflix_titles;

- RANK - returns the rank of the row based on the value. 

>SELECT 
>product_id,
>product_name,
>price,
>RANK () OVER (
>	ORDER BY price DESC
>) price_rank
>FROM
>	products;

